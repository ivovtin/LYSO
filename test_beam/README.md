## Для сборки в test_beam:
gcc -o plotmagnegf_jan2018 -lstdc++ \`root-config --libs --glibs --cflags\` plotmag_neg_jan2018.cc <br />
gcc -o procfltr18jan2 -lstdc++ \`root-config --libs --glibs --cflags\` procn2jan18.cc <br />


## Сборка gemCluster:
1) сделать во всех 3-х директориях(gemCluster,reconstruction,TreeFormats) make clean
и удалить все объектвные файлы (.o) <br />
2) удалить неверные пути в файлах заменив на свою директорию (alexbarn -> ovtin/development): для этого использовать grep -r ovtin . <br />
3) сделать make в reconstruction <br />
4) сделать make в gemCluster<br />

исходники кода лежат в /home/alexbarn/utils/ <br />
данные лежат с прототипов в /home/alexbarn/csipc/ <br />

procn2jan18.cc  - перекачка бинарных файлов от оцифровщика в root-файлы <br />
tot - порог на время <br />
total - число событий <br />

Работаю в директории  ->  2017-12-30_00-49-06 <br />

Файл с данными от daq ->  2017-12-30_00-49.root <br />

1) формирование root-файла с данными из бинарных файлов <br />
../procfltr18jan2 wave_0.dat wave_4.dat wave_2.dat test.root -10000 10 0 0 2 2017-12-30_00-49.root <br />
 если 5 параметр - число событий для обработки, если меньше 0 то обрабатываются все события; <br />
 6 параметр - порог фиксированный в каналах оцифровщика,если меньше нуля, то будет брабатывать 
 всего два файла с оцифровщика, в которых будет искать положительный сигнал и триггер. <br />
 7,8 параметры - x,y координаты подвижки и т.п.           
 dtp в программе в микросекундах, установил 2 секунды, чтобы прокачались все события. <br /> 

2) ../plotmagnegf_jan2018 test.root test_t.root 0 10000 1 0  (if 5 parametr is 1 -> draw graphics) <br />

3) запуск gemCluster <br />
../../gem/gemCluster/gemCluster -o test_gem.root 2017-12-30_00-49.root <br />

test.root <br />
htrg -> амплитуда тригерного МКП в каналах (wave_0.dat) (отрицательный триггер) пьедестал вычитается <br />
htest1 -> амплитуда iMCP(ch1)(wave_4.dat) -> амплитуда прототипа с вычетом пьедестала <br />
ttsimcp1 -> TTS iMCP(T_iMCP-T_MCPPMT -> время между триггером и прототипом <br />

## exbeamdata-> (данные с оцифровщика CAEN V1742)

ch(trg1,trg2)    : nevent/i:number/i:amp[1024]/f:ti[1024]/i:sum/f - информация с тригерного счетчика: номер очередного обработанного события / номер события посчитанный оцифровщиком при записи (восновном совпадают при нашей схеме набора данных)/ массив значений амплитуд из 1024 отсчетов 12-битным АЦП/ номер отсчета (1..1024), чтобы преобразовать во время нужно домножить на временной дискрет, который определяется уставкой оцифровщика, у нас максимальный - 5GSample/sec / интеграл под осциллограммой, считается простым суммированием и потпом делется на число отсчетов (т.е. на 1024) <br />

ch1 : - та же структура только для исследуемого сигнала, как правило, с прототипа <br />

ch(trg1,trg2,1)r : nevent/i:ped/f:min/i:tmin/i:max/i:tmax/i:pedmax/i:pedmin/i:t1/i:t2/i  (реконструированные при перекачке данные по осцилограмам лежащим в ветках без ‘r’) - номер события порядковый / пьедестал посчитанный, как среднее по первым 100 отсчетам (т.е. по первым 20нс, иногда с отступом на 10 первых отсчетов, чтобы не усреднять возможные нули или максимальные значения из АЦП в первом отсчете, надо смотреть код, чтобы понять как сегодня это работает) / минимум осцилограмы по всему диапазону ищется простым перебором / номер отсчета по времени с минимальным значением / максимум осцилограммы по всему диапазону / номер отсчета по времени с максимальным значением / максимум осцилограммы по пьедестальному  диапазону (1..100 отсчет) / минимум осцилограммы по пьедестальному  диапазону (1..100 отсчет) / отсчет в котором осцилограма пересекает первый раз заданный при обработке уровень в числе отсчетов оцифровщика (1..4096) прибавленного и вычтенного из посчитанного пьедестала (определяется опцией при обработке, по-моему если она положительная, то ищется этот момент для отрицательных сигналов, если отрицательная, то для положительных / отсчет в котором осцилограма пересекает второй раз заданный при обработке уровень … <br />

ch1(r)f - то же самое что и ch1 и ch1r, только после пропускания через off-line Butherworth фильтр, который обрезает (сглаживает высокочастотные колебания), верхняя частота настраивается (задается) в коде программы до компиляции когда-то передавал как опцию, но поигравщись оставил то ли 0.9 то ли 1.0ГГц, что не приводит не к ухудшению, ни к улучшению временных разрешений в большинстве случаев, но для более благовидного вида осцилограмм иногда можно поставить поменьше частоту, правда при этом временное разрешение не улучшается, хотя были некоторые надежды, возможно когда нибудь оправдаются. <br /> 

x,y - ветки соответственно координат, которые сейчас передаются как аргументы при обработке, были добавлены, когда начали работать с координатными подвижками и лазером, надеюсь, что когда нибудь в эти ветки будем так же валить координаты из GEM-ов (технически ничего сложного нет, сегодня и так реконструкция подсасывает файл с информацией от GEM-ов, чтобы следить за рассинхронизацией). <br />

ch - номер канала оцифровщика, сейчас передается как аргумент при запуске перекачки в дерево, хотя можно, наверное и брать из шапки файла с данными от оцифровщика, эта ветка полезна когда сливаешь в цепочку данные с нескольких каналов и смотришь взаимные кореляции между каналами контролируя синхронность по номеру события или по timestamp <br />

ts - timestamp из оцифровщика CAEN V1742 (очень точное, лучше 1нс время, но в оцифровщике конечный буфер, поэтому приходится считать их количество, чтобы правильно посчитать время от старта захода) <br /> 

ut - unixtime из файла с GEM-овской информацией, к сожалению в миллисекундах (Василий что-то сделал, чтобы считать в микросекундах, но я пока не прикрутил эту фичу) <br />

tslot - число переполнений буфера timestamp в блоке CAEN V1742 для правильного подсчета ветки ts (заведено для контроля) <br />

dtu - расзница времен (unixtime из GEM-ов) между событиями - для контроля рассинхзронизации уже после перекачки <br />

dtс - расзница времен (по timestamp из CAEN V1742) между событиями - для контроля рассинхзронизации уже после перекачки <br />

## daq-> 

calorimeter : ch0/s:ch1/s:ch2/s:ch3/s - (информация с NaI-калориметра в конце линии оцифрованная КАМАК ЗЦП (ИЯФ, 12 бит), используется обычно ch0, но этим летом видимо в него ничего не включали) <br />

lecroy2249 : ch0/s:ch1/s:ch2/s:ch3/s:ch4/s:ch5/s:ch6/s:ch7/s:ch8/s:ch9/s:ch10/s:ch11/s - (информация с NaI-калориметра в конце линии оцифрованная ЗЦП (Lecroy2249, 10 бит), используется обычно ch0, этим летом только в нем есть информация) <br />

service : time/i:index:utime/l - (времена unix и какое-то еще, вощзможно используется для грубой проверки рассихнронизации) <br />

gem : hitCount/I:eventIndex/S:amplitudes[46080]/S  - (сырая,не реконструированная, информация с GEMов) <br />

## gem-> (реконструированная информация по GEMам полученная из дерева daq)

allClusters.detector (x, y, typex, fUniqueID, …) - информация по всем найденым кластерам в детекторах. Например в каждом детекторе может быть несколько кластеров, от двух частиц, от частицы и шума, от частицы и перекрестной наводки от нее или просто несколько пробоев) <br /> 

detClusters.detector (x, y, typex, fUniqueID, …) - информация по кластерам с максимальной амплитудой, т.к. он считается истинным, а наведенные сигналы как обычно меньше по амплитуде, но это не работает если было две частицы…) <br />

Далее только по detClusters: <br />
detClusters - число задетектированных кластеров не превышает обычно число включенных детекторов, но может быть меньше из-за неэффективности и рассеяния первичных частиц; <br />

detClusters.fBits - …?!?! <br />
	
detClusters.detector[i] - номер детектора (0..3) приписанный к i-тому кластеру <br />

detClusters.typex[i] - …?!?! <br />

detClusters.typey[i] - …?!?! <br />

detClusters.x[i] - восстановленная х-координата i-го кластера <br />

detClusters.y[i] - восстановленная y-координата i-го кластера <br />

detClusters.dx[i] - восстановленная ошибка х-координаты i-го кластера <br />

detClusters.dy[i] - восстановленная ошибка y-координаты i-го кластера <br />

detClusters.ax[i] - амплитуда i-го кластера по х-полоскам (либо восстановленная при помощи фита, либо просто амплитуда с центральной полоски в кластере) <br />

detClusters.ay[i] - амплитуда i-го кластера по y-полоскам (либо восстановленная при помощи фита, либо просто амплитуда с центральной полоски в кластере) <br />

detClusters.max[i] - максимальная амплитуда i-го кластера по х-полоскам (здесь часто совпадает просто с амплитудой, в чем разница надо у Василя Кудрявцева узнавать) <br />

detClusters.may[i] - максимальная амплитуда i-го кластера по y-полоскам (...) <br />

detClusters.rawStraight[i] - предполагаю, что грубо приписанный к кластеру номер прямой полоски, например, с максимальной амплитудой (надо узнавать) <br />

detClusters.rawStereo[i] - предполагаю, что грубо приписанный к кластеру номер прямой полоски, например, с максимальной амплитудой (надо узнавать) <br />



ovtin@stark02 LYSO]$ root -l /home/chizhik/root/2019-06-07_LYSO/2019-06-07_18-53-23/mcplyso2019-06-07_18-53.root <br />
root [0]  <br />
Attaching file /home/chizhik/root/2019-06-07_LYSO/2019-06-07_18-53-23/mcplyso2019-06-07_18-53.root as _file0... <br />
(TFile *) 0x1e68c90 <br />
root [1] new TBrowser <br />
root [3] exbeamdata->Draw("exbeamdata.ch1.ti") <br />
root [4] exbeamdata->Draw("exbeamdata.ch1.amp:exbeamdata.ch1.ti") <br />
root [5] exbeamdata->Draw("exbeamdata.ch1.amp:exbeamdata.ch1.ti","exbeamdata.ch1.number==500","")

## Сдруживание деревьев

root -l test_gem.root <br />
gem->AddFriend("timedat","test_t.root"); <br />
.ls <br />
gem->Print() <br />
gem->Draw("detClusters.x") <br />
gem->Draw("ch1ftcr")  <br />
gem->Draw("ch1ftcr","detClusters.x==60 && detClusters.y==20","") <br />
gem->Draw("ch1ftcr-trgtcr") <br />
gem->Draw("ch1ftcr-trgtcr","detClusters.x>50 && detClusters.x>70","") <br />

